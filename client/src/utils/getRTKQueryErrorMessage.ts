///////////////////////////////////////////////////////////////////////////
//
// ⚠️ Gotcha: The error returned by query and mutation hooks is a footgun:
//
//   const { error } = useGetCategoriesQuery()
//
// The error may be SerializedError | FetchBaseQueryError | undefined.
//
//   import { FetchBaseQueryError } from '@reduxjs/toolkit/query'
//   import { SerializedError } from '@reduxjs/toolkit'
//
// If the error is coming from our server, it will be a FetchBaseQueryError.
// Assuming that our own server convention is to respond with:
//
//   { code: string; data: null; message: string; success: false; }
//
// The message will be on error.data.message. However, in other variations of
// FetchBaseQueryError, the actual message will be on error.error. Finally,
// in the case of SerializeError, it might just be error.message.
//
///////////////////////////////////////////////////////////////////////////

export const getRTKQueryErrorMessage = (error: unknown): string => {
  if (!error) {
    return ''
  }

  if (error && typeof error === 'object') {
    // This implies a FetchBaseQueryError
    if ('data' in error && error.data) {
      // This would be coming directly from our server which uses { code, data, message, success }
      if (
        typeof error.data === 'object' &&
        'message' in error.data &&
        typeof error.data.message === 'string'
      ) {
        return error.data.message
      }
    }

    ///////////////////////////////////////////////////////////////////////////
    //
    // This implies a FetchBaseQueryError, but the error is being generated by RTK Query.
    // In all four cases, there will also be an error.error property, which is a string.
    // However, I've chosen to instead return generic messages rather than expose the actual
    // issue. Why? This function is intended for client UI, not developer debugging. Moreover,
    // the actual raw error.error may be somewhat misleading and inappropriate for UI. For example,
    // in the case of the server simply not being on I got a PARSING_ERROR where the actual error.error was:
    //
    //   "SyntaxError: Unexpected token 'I', \"Internal S\"... is not valid JSON"
    //
    // Obviously, that's not super helpful.
    //
    ///////////////////////////////////////////////////////////////////////////

    if ('status' in error && typeof error.status === 'string') {
      switch (error.status) {
        case 'FETCH_ERROR':
          return 'A fetch error occurred.'

        case 'PARSING_ERROR':
          return 'A parsing error occurred.'

        case 'TIMEOUT_ERROR':
          return 'A timeout error occurred.'

        case 'CUSTOM_ERROR':
          return 'A custom error occurred.'
      }
    }

    // This implies a SerializedError
    if ('message' in error && typeof error.message === 'string') {
      return error.message
    }
  }

  return 'Internal Server Error.'
}
